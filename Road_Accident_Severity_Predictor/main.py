# -*- coding: utf-8 -*-
"""Main.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1z_W5tQufVqN4O8BrSd2vDMKpeMdnBDZs
"""

printy

from google.colab import drive
drive.mount('/content/drive', force_remount=True)
import sys
import pandas as pd
sys.path.insert(0,'/content/drive/My Drive/CS661_Final/Classes')

!pip install keplergl==0.3.2

#Import necessary modules/classes
from google.colab import output
output.enable_custom_widget_manager()
#import class with visualizations class
from visualizations import Visualizations
from data_cleaner import DataCleaner
from accident_severity_predictor import AccidentSeverityPredictor
from bayes import Bayes
import statsmodels.api as sm
from car_damage_ import AccidentSeverityPredictor
from sklearn.tree import DecisionTreeClassifier, plot_tree
import matplotlib.pyplot as plt

"""Support for third party widgets will remain active for the duration of the session. To disable support:"""

clean = DataCleaner('/content/drive/MyDrive/CS661_Final/Data/crash_drivers.csv');
second = pd.read_csv('/content/drive/MyDrive/CS661_Final/Data/crash_incidents.csv')
cleaned = clean.process_data(second,'Report Number', ['Report Number','Road Alignment','Road Condition','Intersection Type'])

visualize = Visualizations(cleaned);

visualize.crash_map()

visualize.crash_map()

visualize.speed_limits()

visualize.intersection()

visualize.surface_conditions()

visualize.weather_conditions()

visualize.catplot()

visualize.catplot_injury()

bayes_df = cleaned.loc[:,['Vehicle Damage Extent','Weather', 'Light', 'Traffic Control', 'Speed Limit', 'Collision Type',
        'Surface Condition', 'Driver Substance Abuse', 'Driver Distracted By', 'Vehicle Movement','Vehicle Body Type', 'Road Alignment', 'Road Condition','Intersection Type']]
bayes_df.drop(bayes_df[bayes_df['Vehicle Damage Extent'] == 'unknown'].index, inplace=True)
bayes_df.drop(bayes_df[bayes_df['Vehicle Damage Extent'] == 'other'].index, inplace=True)

bayes_model = Bayes(bayes_df)
y_test, predictions = bayes_model.categorical_nb()

visualize.generate_and_plot_report(y_test, predictions)

params = {
    'features': [
        'Weather', 'Light', 'Traffic Control', 'Speed Limit', 'Collision Type',
        'Surface Condition', 'Driver Substance Abuse', 'Vehicle Damage Extent',
        'Driver Distracted By', 'Vehicle Movement','Vehicle Body Type', 'Road Alignment', 'Road Condition','Intersection Type'
    ],
    # 'grid_search': {
    #     'param_grid': {
    #         # 'n_estimators': [100, 200],
    #         # 'max_depth': [10, 20],
    #         # 'min_samples_split': [2, 5]
    #         'n_estimators': [10],
    #         'max_depth': [5],
    #         'min_samples_split': [2]
    #     }
    # },
    'balance': True,
    'balance_method': 'smote',  # Options: 'smote', 'adasyn'
    'scale': 'minmax'  # Options:'standard', 'minmax', 'robust'
}
model_type = 'random_forest'  # Options:'logistic_regression', 'gradient_boosting','random_forest'
target = 'Injury Severity'
predictor = AccidentSeverityPredictor(cleaned, params, target, model_type)

predictor.execute_full_workflow()
predictor.display_labels()

predictions = predictor.model.predict(predictor.X_test)
visualize.generate_and_plot_report(predictor.y_test, predictions)

"""Execute Roberto's Models"""

params = {
    'features': [
        'Weather', 'Light', 'Traffic Control', 'Speed Limit', 'Collision Type',
        'Surface Condition', 'Driver Substance Abuse', 'Vehicle Damage Extent',
        'Driver Distracted By', 'Vehicle Movement','Vehicle Body Type', 'Road Alignment', 'Road Condition','Intersection Type'
    ],
    # 'grid_search': {
    #     'param_grid': {
    #         # 'n_estimators': [100, 200],
    #         # 'max_depth': [10, 20],
    #         # 'min_samples_split': [2, 5]
    #         'n_estimators': [10],
    #         'max_depth': [5],
    #         'min_samples_split': [2]
    #     }
    # },
    'balance': True,
    'balance_method': 'smote',  # Options: 'smote', 'adasyn'
    'scale': 'minmax'  # Options:'standard', 'minmax', 'robust'
}
model_type = 'logistic_regression'  # Options:'logistic_regression', 'gradient_boosting','random_forest'

predictor = AccidentSeverityPredictor(cleaned, params, target, model_type)

predictor.execute_full_workflow()
predictor.display_labels()

predictions = predictor.model.predict(predictor.X_test)
visualize.generate_and_plot_report(predictor.y_test, predictions)

params = {
    'features': [
        'Weather', 'Light', 'Traffic Control', 'Speed Limit', 'Collision Type',
        'Surface Condition', 'Driver Substance Abuse', 'Vehicle Damage Extent',
        'Driver Distracted By', 'Vehicle Movement','Vehicle Body Type', 'Road Alignment', 'Road Condition','Intersection Type'
    ],
    # 'grid_search': {
    #     'param_grid': {
    #         # 'n_estimators': [100, 200],
    #         # 'max_depth': [10, 20],
    #         # 'min_samples_split': [2, 5]
    #         'n_estimators': [10],
    #         'max_depth': [5],
    #         'min_samples_split': [2]
    #     }
    # },
    'balance': True,
    'balance_method': 'smote',  # Options: 'smote', 'adasyn'
    'scale': 'minmax'  # Options:'standard', 'minmax', 'robust'
}
model_type = 'gradient_boosting'  # Options:'logistic_regression', 'gradient_boosting','random_forest'

predictor = AccidentSeverityPredictor(cleaned, params, target, model_type)

predictor.execute_full_workflow()
predictor.display_labels()

predictions = predictor.model.predict(predictor.X_test)
visualize.generate_and_plot_report(predictor.y_test, predictions)

params2 = {'features': ['Collision Type', 'Weather', 'Light', 'Traffic Control', 'Speed Limit']}
model = DecisionTreeClassifier(random_state=42)
accident_predictor = AccidentSeverityPredictor(cleaned, params2, model)
accident_predictor.execute_full_workflow()
plt.figure(figsize=(20,10))
plot_tree(model, feature_names=accident_predictor.features, class_names=[str(i) for i in model.classes_], filled=True)
plt.show()

accident_predictor = AccidentSeverityPredictor(cleaned, params2, model)
accident_predictor.execute_full_workflow()
accident_predictor.display_label_mapping()
predictions = accident_predictor.model.predict(accident_predictor.X_test)
visualize.generate_and_plot_report(accident_predictor.y_test, predictions)